## 微信小程序

### rpx

> response px 响应式像素

小程序独有的像素单位

## 全局配置

### 	获取app.js中的data数据（全局变量）

```vue
// 任意的js文件中
const app = getApp()
app.userInfo     // 123

// app.js
data {
	userInfo: 123
}
```

# 视图层

## 标签

```html
view = div

text = span

// <block/> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性
block = template
```

## 页面渲染

### 条件标签渲染

> wx:if 等价于 vue 中的v-if

```vue
<view wx:if="{{flag}}"></view>
```

### 循环标签渲染

> wx:for 等价于vue中的 v-for
>
> 默认wx:for 的index和item为初始值，使用wx:for-index和wx:for-item可以指定其他变量名
>
> wx:key有两个值，*this为当前遍历的item，也可以直接指向遍历元素的属性（例如id）

```
<view wx:for="{{list}}" wx:key="id || *this" wx:for-index="index" wx:for-item="item">
	{{item}}
</view>

Page({
	data: {
		list: [{
			id: 1,
			name: 123,
		}]
	}
})

======== 使用block渲染
<block wx:for="{{[1, 2, 3]}}">
 <view> {{index}}: </view>
 <view> {{item}} </view>
</block>
```

### 模板和模板引用

> 在wxml文件中使用<template name="模板名称">标签则可以创建模板

```vue
// a.wxml
<template name="temp">
	123
</template>
```

> 使用import引用模板，使用后，只会引用该文件中的template标签

```vue
<import src="a,wxml" />
<template is="引入的模板的name" data="{{data}}"></template>

=========== is 属性可以使用mustache语法
<template is="{{falg ? a.wxml : b.wxml}}"></template>
```

> 使用include引用模板，使用后，只会引用该文件中的除了template，wxs标签外其他内容，并且会直接覆盖到include标签

```vue
<include src="header.wxml"/>
```



# 逻辑层

## Page构造函数（用于逻辑简单的页面）

> 每个js文件都有page构造函数，里面含有初始化钩子和data初始化变量
>
> 注：page构造函数中没有methods，无法自定义方法

```vue
Page({
	data: {
    text: "This is page data."
  },
  onLoad: function(options) {
    // 页面创建时执行
  },
  onShow: function() {
    // 页面出现在前台时执行
  },
  onReady: function() {
    // 页面首次渲染完毕时执行
  },
  onHide: function() {
    // 页面从前台变为后台时执行
  },
  onUnload: function() {
    // 页面销毁时执行
  },
  onPullDownRefresh: function() {
    // 触发下拉刷新时执行
  },
  onReachBottom: function() {
    // 页面触底时执行
  },
  onShareAppMessage: function () {
    // 页面被用户分享时执行
  },
  onPageScroll: function() {
    // 页面滚动时执行
  },
  onResize: function() {
    // 页面尺寸变化时执行
  },
  onTabItemTap(item) {
    // tab 点击时执行
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  },
  // 事件响应函数
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    }, function() {
      // this is setData callback
    })
  },
  // 自由数据
  customData: {
    hi: 'MINA'
  }
})
```

## Component构造函数（用于复杂页面）

> 可以在component构造函数中使用methods进行自定义方法

### 组件的生命周期

| 生命周期 |     参数     |                   描述                   |
| :------: | :----------: | :--------------------------------------: |
| created  |              |        在组件实例刚刚被创建时执行        |
| attached |              |      在组件实例进入页面节点树时执行      |
|  ready   |              |       在组件在视图层布局完成后执行       |
|  moved   |              | 在组件实例被移动到节点树另一个位置时执行 |
| detached |              |    在组件实例被从页面节点树移除时执行    |
|  error   | object error |        每当组件方法抛出错误时执行        |

- created：组件实例刚刚被创建好时， `created` 生命周期被触发。此时，组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` 。 **此时还不能调用 `setData` 。** 通常情况下，这个生命周期只应该用于给组件 `this` 添加一些自定义属性字段。
- attached：在组件完全初始化完毕、进入页面节点树后， `attached` 生命周期被触发。此时， `this.data` 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。（等价于mounted）
- detached：在组件离开页面节点树后， `detached` 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 `detached` 会被触发。

### 使用lifetimes来定义

用法：

```vue
Component({
	// 新写法
	lifetimes: {
        attached: function() {
          // 在组件实例进入页面节点树时执行
        },
        detached: function() {
          // 在组件实例被从页面节点树移除时执行
        },
  	}
	// 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
      attached: function() {
        // 在组件实例进入页面节点树时执行
      },
      detached: function() {
        // 在组件实例被从页面节点树移除时执行
      },
}
})
```

### 特殊生命周期（组件在页面中的生命周期）

> 使用pagelifetimes来定义（在2.2.3以下的版本可以在Component中直接定义）

| 生命周期 |    参数     |             描述             |
| :------: | :---------: | :--------------------------: |
|   show   |             |  组件所在的页面被展示时执行  |
|   hide   |             |  组件所在的页面被隐藏时执行  |
|  resize  | object size | 组件所在的页面尺寸变化时执行 |



```vue
Component({
  pageLifetimes: {
    show: function() {
      // 页面被展示
    },
    hide: function() {
      // 页面被隐藏
    },
    resize: function(size) {
      // 页面尺寸变化
    }
  }
})
```

### Behaviors（理解为vue的混入mixin）

> 注意，Behavior函数中使用的生命周期函数没有on，Page构造函数中才有
>
> behaviors中也可以使用组件生命周期，当同一个behaviors被多次引用时，生命周期只会执行一次

```javascript
// my-behavior.js
module.exports = Behavior({
  data: {
    sharedText: 'This is a piece of data shared between pages.'
  },
  methods: {
    sharedMethod: function() {
      this.data.sharedText === 'This is a piece of data shared between pages.'
    }
  }
})
```

```javascript
// page-a.js
var myBehavior = require('./my-behavior.js')
Page({
  behaviors: [myBehavior],
  onLoad: function() {
    this.data.sharedText === 'This is a piece of data shared between pages.'
  }
})
```

### properties传值（等价于prop）

|    参数名     |                描述                |
| :-----------: | :--------------------------------: |
|     type      |             属性的类型             |
|     value     |               默认值               |
| optionalTypes |      属性的类型（可以指多个）      |
|   observer    | 监听变化（返回修改的值和传入的值） |



```vue
Component({
  properties: {
    min: {
      type: Number,
      value: 0
    },
    min: {
      type: Number,
      value: 0,
      observer: function(newVal, oldVal) {
        // 属性值变化时执行
      }
    },
    lastLeaf: {
      // 这个属性可以是 Number 、 String 、 Boolean 三种类型中的一种
      type: Number,
      optionalTypes: [String, Object],
      value: 0
    }
  }
})
```

## 路由

### wx.switchTab

> 清空栈中的页面，只保留切换的tabbar页面

```vue
wx.switchTab({
  url: '/index'
})
```



### wx.navigateTo

> 保留当前页面，跳转到其他页面（不能去tabbar），最多跳转10层，可以使用wx.navigateBack() 返回上一层

```vue
wx.navigateTo({
  url: 'test?id=1&name="123"',
  events: {
    // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据
    a: function(data) {
      console.log(data)
    },
    b: function(data) {
      console.log(data)
    }
  },
  success: function(res) {
    // 通过eventChannel向被打开页面传送数据
    res.eventChannel.emit('c', { data: 'test' })
  }
})
```

```vue
//test.js
Page({
  onLoad: function(option){
    console.log(option.query)
    const eventChannel = this.getOpenerEventChannel()
    eventChannel.emit('a', {data: 'test'});
    eventChannel.emit('b', {data: 'test'});
    // c，获取上一页面通过eventChannel传送到当前页面的数据
    eventChannel.on('c', function(data) {
      console.log(data)
    })
  }
})
```



